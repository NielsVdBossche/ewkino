#include "../../Tools/interface/SusyScan.h"

//include c++ library classes
#include <iostream>
#include <exception>

//include other parts of framework
#include "../../Tools/interface/Sample.h"
#include "../../Event/interface/Event.h"


int main(){

    Sample susySample = Sample( "../testData/TChiWZ_1_Summer16.root", false, false, false );

    //load the information about the susy scan through the corresponding class
    SusyScan susyScan( susySample );

    //manually load the number of points by looping over the sample
    std::set< std::pair< unsigned, unsigned > > manualMasses;
    std::set< unsigned > manualMassSplittings;
    TreeReader treeReader;
    treeReader.initSampleFromFile( "../testData/TChiWZ_1_Summer16.root" );
    for( long unsigned entry = 0; entry < treeReader.numberOfEntries(); ++entry ){
        Event event = treeReader.buildEvent( entry );
        manualMasses.insert( { static_cast< unsigned >( event.susyMassInfo().massNLSP() ), static_cast< unsigned >( event.susyMassInfo().massLSP() ) } );
        manualMassSplittings.insert( static_cast< unsigned >( std::abs( event.susyMassInfo().massNLSP() - event.susyMassInfo().massLSP() ) ) );
    }

    //compare the number of points
    if( susyScan.numberOfPoints() != manualMasses.size() ){
        throw std::runtime_error( "SusyScan finds " + std::to_string( susyScan.numberOfPoints() ) + " mass points, while a manual loop over the sample finds " + std::to_string( manualMasses.size() ) + "." );
    }

    //check that each point found by the SusyScan class is also found in the manual loop
    for( const auto& manPair : manualMasses ){
        double mChi2 = static_cast< double >( manPair.first );
        double mChi1 = static_cast< double >( manPair.second );

        //rely on the internal error checks of SusyScan, they will catch unknown indices
        susyScan.index( mChi2, mChi1 ); 
    }

    //check that each point found by manually looping is also in the SusyScan class
    for( size_t index = 0; index < susyScan.numberOfPoints(); ++index ){
        auto massPair = static_cast< std::pair< unsigned, unsigned > >( susyScan.masses( index ) );
        auto it = manualMasses.find( massPair );
        if( it == manualMasses.cend() ){
            throw std::runtime_error( "Mass point " + susyScan.massesString( index ) + " not found in manual loop over sample." );
        }
    }

    //check if list of manual mass splittings corresponds to the list generated by the SusyScan class
    std::vector< unsigned > massSplittingVector = susyScan.massSplittings();
    std::set< unsigned > massSplittings( massSplittingVector.cbegin(), massSplittingVector.cend() );
    for( const auto& deltaM : massSplittings ){ 
        if( manualMassSplittings.find( deltaM ) == manualMassSplittings.cend() ){
            throw std::runtime_error( "Mass splitting " + std::to_string( deltaM ) + " not found in manual loop over sample." );
        }
    }
    for( const auto& deltaM : manualMassSplittings ){
        if( massSplittings.find( deltaM ) == massSplittings.cend() ){
            throw std::runtime_error( "Mass splitting " + std::to_string( deltaM ) + " not found by SusyScan class." );
        }
    }

    //make SusyScan with a requested deltaM and check that all points have this deltaM 
    for( const auto& deltaM : massSplittings ){
        SusyScan deltaMScan( susySample, deltaM );
        for( const auto& entry : deltaMScan.massSplittings() ){
            if( entry != deltaM ){
                throw std::runtime_error( "Mass splitting " + std::to_string( entry ) + " found in SusyScan that should only contain splitting " + std::to_string( deltaM ) + "." );
            }
        }
    }
    
    //check that all massSplittings within a certain window from a given mass splitting are present
    const double interval = 100.;
    for( const auto& deltaM : massSplittings ){
        SusyScan deltaMIntervalScan( susySample, std::max( static_cast< double >( deltaM ) - interval, 0. ), deltaM + interval );
        for( const auto& entry : massSplittings ){
            if( std::abs( static_cast< double >( entry ) - static_cast< double >( deltaM ) ) <= interval ){
                if( !deltaMIntervalScan.containsMassSplitting( entry ) ){
                    throw std::runtime_error( "Mass splitting " + std::to_string( entry ) + " should be contained in susyScan with interval " + std::to_string( interval ) + " and central splitting " + std::to_string( deltaM ) + "." );
                }
            } else {
                if( deltaMIntervalScan.containsMassSplitting( entry ) ){
                    throw std::runtime_error( "Mass splitting " + std::to_string( entry ) + " should not be contained in susyScan with interval " + std::to_string( interval ) + " and central splitting " + std::to_string( deltaM ) + "." );
                }
            }
        }
    }
}
